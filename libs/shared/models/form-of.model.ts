import { FormArray, FormControl, FormGroup } from '@angular/forms';

/**
 * Helper type that generates a union of dot-separated paths for nested properties of type T.
 * For a given object, it returns keys in the format "key" or "key.nestedKey".
 * Built-in types such as Date and arrays (including tuples) are omitted.
 *
 * @template T - The type from which paths are to be generated.
 *
 * @example
 * interface Example {
 *   a: string;
 *   b: {
 *     c: number;
 *   };
 * }
 * // DotPaths<Example> resolves to: "a" | "b" | "b.c"
 */
type DotPaths<T> = T extends Date
	? never
	: T extends readonly any[]
		? never
		: T extends object
			? {
					[K in Extract<keyof T, string>]: T[K] extends Date | readonly any[]
						? `${K}`
						: T[K] extends object
							? `${K}` | `${K}.${DotPaths<T[K]>}`
							: `${K}`;
				}[Extract<keyof T, string>]
			: never;

/**
 * Helper type that extracts nested exclusion for a given key K from the union Excluded.
 * For example, if Excluded is "notice.dateRange" and K is "notice", it returns "dateRange".
 *
 * @template Excluded - Union of exclusion paths.
 * @template K - The current key.
 */
type NestedExcluded<
	Excluded extends string,
	K extends string,
> = Excluded extends `${K}.${infer Rest}` ? Rest : never;

/**
 * Recursive type that maps a given schema T to a typed Angular form model.
 *
 * Allows specifying exclusions as paths (e.g., "notice.dateRange"), with the Excluded parameter
 * constrained to valid paths generated by {@link DotPaths<T>}, preserving IDE autocompletion.
 *
 * Transformation rules:
 *
 * 1. Built-in types (e.g., Date) are mapped to {@link FormControl}. If Nullable is true, the control type is
 *    e.g., `Date | null`.
 * 2. Arrays and tuples are mapped to {@link FormArray}, with elements recursively mapped.
 * 3. Objects are mapped to {@link FormGroup}. For each property:
 *    - If the exact path (key) is present in Excluded, the property is wrapped in {@link FormControl}
 *      (without further recursion).
 *    - If there is a nested exclusion for key K (i.e., Excluded contains e.g., "K.someKey"),
 *      then the property K is recursively transformed with Excluded set to the inner exclusion.
 *    - Otherwise, full recursion is performed.
 * 4. Primitive types (string, number, etc.) are mapped to {@link FormControl}.
 *
 * @template T - The form schema.
 * @template Excluded - Union of paths to exclude, constrained to {@link DotPaths<T>}.
 *                      Defaults to `never`.
 * @template Nullable - Specifies whether controls should be nullable (default: true).
 *
 * @example
 * interface ClaimFinderSearchFormSchema {
 *   basicCriteria: BasicCriteriaSearchForm;
 *   notice: NoticeForm;
 * }
 *
 * interface NoticeForm {
 *   dateRange: [Date, Date | undefined];
 *   form: string[];
 *   state: string[];
 *   operator: string;
 * }
 *
 * // Exclude the dateRange property in the notice object from recursion:
 * type ClaimFinderForm = FormOf<ClaimFinderSearchFormSchema, "notice.dateRange">;
 */
export type FormOf<
	T,
	Excluded extends DotPaths<T> = never,
	Nullable extends boolean = true,
> = T extends Date
	? FormControl<Nullable extends true ? T | null : T>
	: T extends readonly any[]
		? FormArray<FormOf<T[number], Excluded, Nullable>>
		: T extends object
			? FormGroup<{
					[K in keyof T]: K extends string
						? K extends Excluded
							? FormControl<Nullable extends true ? T[K] | null : T[K]>
							: NestedExcluded<Excluded, K> extends never
								? // @ts-expect-error: Excluded raises an error here which is controlled and doesn't lead to any lafunction in FormOf type in general
									FormOf<T[K], Excluded, Nullable>
								: // @ts-expect-error: Excluded raises an error here which is controlled and doesn't lead to any lafunction in FormOf type in general
									FormOf<T[K], NestedExcluded<Excluded, K>, Nullable>
						: never;
				}>
			: FormControl<Nullable extends true ? T | null : T>;
